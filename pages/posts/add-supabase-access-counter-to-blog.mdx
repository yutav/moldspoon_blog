import { Layout } from 'lib/components'
import RichList from "lib/components/original/parts/RichList"
import RichListNoBox from "lib/components/original/parts/RichListNoBox"
import CodeBlockTitle from "lib/components/original/parts/CodeBlockTitle"
import MdxImage from "../../lib/components/original/parts/MdxImage"

export const meta = {
  title: 'Next.js製ブログにアクセスカウンターを追加する作業でSupabase使ってみた。',
  date: '2023-08-31T06:50:00.000Z',
  tags: [
    'Next.js',
    'Blog',
    'Vercel',
    'フロントエンド',
    'アクセスカウンター',
    'Supabase',
    'Postgres',
    'React hook',
    'プログラミング'
  ]
}

アクセスカウンターって昔流行りましたね。ただ、今はWordpress以外で、簡単にアクセスカウンターを実現する方法がなかなかないのも事実。（バックエンドがあると楽だけど）ということで、IaaSの**Supabase**を使って作ってみました。

### 本記事のゴール

ブログにアクセスカウンターを追加する。
その際に、[Supabase](https://supabase.com/)をバックエンドとして使用する。

<RichList
  color="orange"
  title="要件定義"
  list={
  [
    '同じユーザーがアクセスした場合は、カウントしない。',
    '同一日でなければ、再カウント可能とする',
    '1ページ1カウントとする。'
  ]
} />

### 設計

- 各ページマウント時に、useEffectを使い、現在のPV数を確認する。
- 各ページで、**ローカルストレージに保存したランダム文字列**をトリガーにSuparbaseへの参照系(select)リクエストを行い、データの有無を確認する。
  - セキュリティ要件が厳しくないため、ローカルストレージで問題ない。（ローカルストレージでダメな場合は別途方法を検討する必要があるが今回は別の話）
  - ランダム文字列が同一でも他の環境からリクエストはできるが、そこまでタイトな用件ではないため妥協する。
  - 同一日かどうかは、dateカラムを作り判定を行う。
  - 既にデータがある場合は何もしない。データがまだない時は、更新系(insert)リクエストを行い、DBに保存する。

### DB設計・準備をSupabaseで

アカウント・プロジェクト作成後、

- APIキー
- プロジェクトURL(エンドポイント)

を`.env.環境名`に保存します。以下はlocalの例を書きます。

<CodeBlockTitle title=".env.local" />

```typescript
NEXT_PUBLIC_SUPABASE_URL=https://xxxxxxxxxxxxxxx.supabase.co
NEXT_PUBLIC_SUPABASE_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

これらはプロジェクトページに移動後、「Settings」->「API」から取得できます。

#### pageviews/pageview_detailsテーブルを作成

ダッシュボードから、table -> 「Create New Table」で新たにテーブルを作成していきます。

#### pageviews

テーブル名を**pageviews**
キーとなる`id`および`created_at`に加えて、以下の3カラムを追加

- slug varchar // 各ページのドメイン以下のURIをスラグとして入れます
- pageview int8
- updated_at (defaultはnow())

全てIs Nullableのチェックを外しておきます。（Nullが入ることは想定していないです。）

#### pageview_details
テーブル名を**pageviews**
こちらも以下の3カラムを追加

- slug varchar // 各ページのドメイン以下のURIをスラグとして入れます
- random varchar // localStorageに設定するランダム文字列
- date date // 本日の日付のみ走査対象とします

同じくIs Nullableのチェックを外しておきます。（

##### ※ 注意点

**各テーブルの作成時にデフォルトでRLSがONになるので注意してください。**
Supabaseでは下記のようなRLSを編集するツール(AWSでいうIAMのポリシーを編集するツール)が付属していますので
こちらで適切に権限を設定してください。

<MdxImage month="202309" image="rls-policy.png" month="202309" />

後述しますが、このポリシー編集ツールがまだ完成度粗いな...と個人的には思ってしまいました。
AWSだと名称から直感的に、「S3ReadOnlyAccess」みたいなRoleをくっつけられますよね。

あのような豊富な雛形があるといいですし、**英語ネイティブでない日本人にとっては微妙な表現の読み違えで真逆の設定をしかねない**と思うので、日本語対応を期待しています。

### 実装

#### ライブラリをNext.jsプロジェクトにインストール

プロジェクトのルートに移動し、yarnでインストールを実施します。

```
yarn add @supabase/supabase-js
```

#### layout.tsx / hooksの形で実装

ブログの詳細ページ共通で呼ばれるコンポーネントであればどこでも良いと思います。

私はhook形式にした上で、レイアウトコンポーネントで
呼ぶようにしました。_app.tsxからだと、利用するViewからは階層が遠く引き回す方法を考えないといけないからです。（Contextを使えばできるが、そこまでしなくてもいいかなと）

<CodeBlockTitle title="lib/components/layout.tsx" />

```typescript
import React from 'react'
import "remixicon/fonts/remixicon.css"
import { useRouter } from "next/router"
import { usePageCounter } from 'hooks/usePageCounter'

type LayoutProps = {
  children: React.ReactNode
}

const Layout: React.FC<LayoutProps> = ({
  children
}) => {

  const router = useRouter()
  const currentUrl = typeof window !== 'undefined' ? window.location.href : '';
  const isDetailPage = router.pathname.startsWith('/posts');

  // hooksで、中身で全ての処理を完結させる
  const [{ pageView }] = usePageCounter({
    slug: router.asPath
  })

  // 以下はお手元のlayout.tsxの内容を移植してください。
  return (
    <>
      {children}
    </>
  )
}

export default Layout

```

#### usePageCounter.tsx / randomコードをフックに全てを処理する

ページ描画時に、`useEffect()`が呼ばれ、localStorageから保存済みのランダム文字列があれば呼ばれます。なければ新規に作っています。

これをフックにして、DB参照を行い、

- 1. 既にテーブルにレコードがあれば+1
- 2. レコードがなければ新規作成

という流れになります。

<CodeBlockTitle title="hooks/userPageCounter.tsx" />

```typescript
import { useEffect, useState } from "react"
import { createClient } from '@supabase/supabase-js'
import { getRandomString } from "lib/utils"

const supabaseUrl = process.env.SUPABASE_URL || ''
const supabaseKey = process.env.SUPABASE_KEY || ''

const supabase = createClient(supabaseUrl, supabaseKey)

export const usePageCounter = ({ slug }: {
  slug: string
}) => {

  const [pageView, setPageView] = useState(0)
  const [random, setRandom] = useState("")

  // ランダム文字列の発行および取得ロジック
  useEffect(() => {
    const storedRandom = localStorage.getItem('pageCounterRandom');
    if (storedRandom) {
      setRandom(storedRandom)
    } else {
      const newRandom = getRandomString()
      localStorage.setItem('pageCounterRandom', String(newRandom));
      setRandom(String(storedRandom))
    }
  }, []);

  const fetchPageView = async (slug: string) => {
    const { data, error } = await supabase
      .from('pageviews')
      .select()
      .eq('slug', slug)
    return { data, error }
  }

  const fetchPageViewDetail = async (slug: string, random: string) => {
    const { data, error } = await supabase
      .from('pageview_details')
      .select()
      .eq('slug', slug)
      .eq('random', random)
      .eq('date', new Date().toISOString())
    return { data, error }
  }

  // NOTE: 本来はdataを型指定するべきだが、supabase loginなど作業が必要なため、一旦anyで判定
  const upsertPageview = async (data: any, slug: string) => {
    let id
    let pageview = 1 // 初期値は0ではなく1
    if (data.length > 0) {
      id = data[0].id
      pageview = data[0].pageview + 1 // increment
    }
    const { data: dataUpsert, error: errorUpsert } = await supabase
      .from('pageviews')
      .upsert({
        id: id,
        slug: slug,
        pageview: pageview
      })
      .select()
    return { dataUpsert, errorUpsert }
  }

  const insertPageViewDetail = async (slug: string, random: string) => {
    const { error } = await supabase
      .from('pageview_details')
      .insert({
        slug: slug,
        random: random,
        date: new Date().toISOString()
      })
    return { error }
  }

  useEffect(() => {
    if (random === "") {
      return
    }

    const executePageCounter = async () => {

      let { data, error } = await fetchPageView(slug)
      let { data: detailData, error: detailError } = await fetchPageViewDetail(slug, random)
      if (error || data == undefined || detailError || detailData == undefined) {
        // add error handling if needed
        return
      }
      // 既に詳細データがある場合は、何もしないで終了する
      if (data.length > 0 && detailData.length > 0) {
        setPageView(data[0].pageview);
        return
      }

      //　データがない場合は新規作成する
      await insertPageViewDetail(slug, random)
      const { dataUpsert, errorUpsert } = await upsertPageview(data, slug)
      if (errorUpsert || dataUpsert == undefined) {
        // add error handling if needed
        return
      }

      // 処理が終わってからpageviewを更新
      setPageView(dataUpsert[0].pageview);
    }

    executePageCounter()
  }, [random])

  return [{ pageView }]
}
```

##### ※ ランダム文字列の発行ロジック

一例ですがこちら
[https://www.slingacademy.com/article/ways-to-generate-random-strings-in-javascript/](https://www.slingacademy.com/article/ways-to-generate-random-strings-in-javascript/
)
などを適宜実装してください。上記のusePageCounterで申しますと`getRandomString()`のところです。

私はこちらを使っていませんが、適宜作成し、util的なファイルに気軽に呼べるメソッドとして追加。
あるいはhooks集などにあるやつを適宜採用ください。

#### 動作確認（テスト）

ローカルで`yarn run dev`でプロジェクトを起動し、ブログページでカウンターの増加を確認します。

<MdxImage month="202309" image="pv-increment.png" month="202309" />

うん、ちゃんと増えてる。

### まとめ

私の方でSupabaseを使ったのは初めてでしたので、自分のため、が主目的とはなりますが今回長短所を軽く整理してみました。

数ヶ月〜かかるような中大規模プロジェクトへの導入を前提に検討していないため、粗があるかと思いますのでその点はお許しをいただけますと幸いです。

#### 長所

<RichListNoBox
  color="red"
  list={
  [
    'バックエンドフレームワークのORMのような感覚でDBに繋げ、RDB経験が豊富な人には使いやすい。',
    'エラーハンドリングがSingleで実装でき、React経験豊富な人にもわかりやすい。',
    '要するにどちらか片方の技術スタックを持っていればとっつきやすい。イコール、プロジェクトにおいて人材の確保などもしやすい。',
    'RDBなので、NoSQLに比べて複数人数での開発プロジェクトに適応しやすそう（この辺りのフィジビリはまだまだなので、稿を改めて）',
    '意外に現時点でもフィルターはサンプルも豊富にあり充実していそうだった。（自分で試せてない）',
    '中身Postgresqlなので、移植は普通にしやすい。supabaseコマンド経由でバックアップも取れるし、<a href="https://zenn.dev/www_y/articles/a1e0c61a12b57c">psqlでダンプもどうやら取れる</a>らしい'
  ]
} />

#### 短所

<RichListNoBox
  color="red"
  list={
  [
    'Vercel/AWS/GCPなどと比べてGUIが過渡期でこなれていない',
    '<span className="font-bold">GUIでDBを操作するのがそもそもめんどくさい。</span>',
    'と思ったら、<a href="https://qiita.com/SuyamaDaichi/items/aa3cf41684c820ff654e">TablePlusなどのDBクライアントで接続する方法を見つけた</a>...のであまり短所にならないかも？',
    '日本語化に対応しておらず、コミュニティの日本語情報もまだまだ。（gql系の技術とかにも通じる話で、ナレッジが蓄積されたら便利そう）',
  ]
} />
<br />


総括すると、既存のRestAPI + RDBと比べると2023/09時点では効率悪いなと思っちゃうところが多いです。
<br />

技術選定にあたっては、**「この技術に未来はあるのか？」** という観点で考えるわけですが、RDBとGUIを組み合わせたIaaSという発想は筋がいいと思います。
「データが膨らんだ時にスケーラブルに利用継続できるのと差し替えに、NoSQL使うのはしんどい」とか「学習コストが高い」という話はずっと続いてたので。
<br />
ただ、利用者はエンジニアである以上最終的には**GUIはオマケにしかならないじゃないか** という話もあります。
つまり、SupabaseはクラウドDBサービスであることが価値の源泉であり、IaaSとしては厳密にはみられてないのだと思います。
<br />
技術選定に時間がかけられる大規模案件ならともかくCUIよりも使いやすいGUIを利用しながら待っているわけには個人開発ではいかないので、`supabase`コマンドを使ったり
前述のように`Tableplus`を使って対応するようになりそうですが、そうなるといよいよ更に簡便に使える`Firebase`やRDSなどの既存のDBサービスでもいい気がしてきちゃいますね。
<br />
ということで、あくまで私一人の意見ですが個人開発で使うのは微妙だと思います...
数ヶ月・複数人のプロジェクトで試しに使ってみるのはいいと思いました！
<br />
この記事が何かのお役に立てれば幸いです。<br />
最後までお読みいただきありがとうございました！

export default function Page({ children }) {
  return (
    <Layout meta={meta}>
      <>
        {children}
      </>
    </Layout>
  )
}

